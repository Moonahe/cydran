import Logger from "./logger/Logger";
import Listener from "./messaging/Listener";
import ModelMediator from "./ModelMediator";
import Module from "./Module";
import RegistryStrategy from "./RegistryStrategy";
declare class ModuleImpl implements Module {
    private name;
    private registry;
    private broker;
    constructor(name: string);
    getName(): string;
    associate(...componentClasses: any[]): Module;
    disassociate(...componentClasses: any[]): Module;
    clear(): Module;
    broadcast(channelName: string, messageName: string, payload: any): void;
    addListener(listener: Listener): void;
    removeListener(listener: Listener): void;
    get<T>(id: string): T;
    getLocal<T>(id: string): T;
    registerConstant(id: string, instance: any): Module;
    registerPrototype(id: string, classInstance: any): Module;
    registerSingleton(id: string, classInstance: any): Module;
    addStrategy(strategy: RegistryStrategy): Module;
    expose(id: string): Module;
}
declare class Modules {
    static getModule(name: string): Module;
    static getDefaultModule(): Module;
    static forEach(fn: (instace: Module) => void): void;
    static broadcast(channelName: string, messageName: string, payload: any): void;
    static registerConstant(id: string, instance: any): void;
    static registerPrototype(id: string, classInstance: any): void;
    static registerSingleton(id: string, classInstance: any): void;
    static registerDecorator(name: string, supportedTags: string[], decoratorClass: any): void;
    static registerFilter(name: string, fn: Function): void;
    static get<T>(id: string): T;
    private static modules;
}
declare abstract class Component {
    private logger;
    private el;
    private regions;
    private parentView;
    private componentName;
    private id;
    private template;
    private mvvm;
    private pubSub;
    private metadata;
    constructor(componentName: string, template: Function);
    hasMetadata(name: string): boolean;
    getMetadata(name: string): any;
    setEl(el: HTMLElement): void;
    setParentView(parentView: Component): void;
    getRegion(name: string): Region;
    digest(): void;
    setChild(name: string, component: Component): void;
    setChildFromRegistry(name: string, componentName: string, defaultComponentName?: string): void;
    message(channelName: string, messageName: string, payload: any): void;
    broadcast(channelName: string, messageName: string, payload: any): void;
    broadcastGlobally(channelName: string, messageName: string, payload: any): void;
    dispose(): void;
    getId(): number;
    protected watch(expression: string, target: (previous: any, current: any) => void): void;
    protected withMetadata(name: string, value: any): void;
    protected listenTo(channel: string, messageName: string, target: Function): void;
    protected get<T>(id: string): T;
    protected render(): void;
    protected $apply(fn: Function, ...args: any[]): void;
    protected getEl(): HTMLElement;
    protected getParentView(): Component;
    protected getLogger(): Logger;
    protected wire(): void;
    protected unwire(): void;
    private notify;
    protected abstract wireListeners(): void;
    private wireInternal;
    private unwireInternal;
    protected getModule(): Module;
    static associate(moduleInstance: Module): void;
    static disassociate(): void;
}
declare abstract class Decorator<T> {
    private logger;
    private el;
    private model;
    private expression;
    private previous;
    private value;
    private mvvm;
    private parentView;
    private moduleInstance;
    private prefix;
    private mediator;
    private params;
    constructor(mvvm: Mvvm, parentView: Component, el: HTMLElement, expression: string, model: any, prefix: string);
    dispose(): void;
    init(): void;
    get<U>(id: string): U;
    setModule(moduleInstance: Module): void;
    protected getEl(): HTMLElement;
    protected mediate(expression: string): ModelMediator;
    protected getParam(name: string, defaultValue?: string): string;
    protected getRequiredParam(name: string, defaultValue?: string): string;
    protected getModel(): any;
    protected getParentView(): Component;
    protected getMediator(): ModelMediator;
    protected notifyModelInteraction(): void;
    protected getExpression(): string;
    protected abstract wire(): void;
    protected abstract unwire(): void;
}
declare class Region {
    private el;
    private component;
    private parentView;
    private logger;
    private name;
    constructor(name: string, parentView: Component);
    setEl(el: HTMLElement): void;
    setComponent(component: Component): void;
    dispose(): void;
    private wireEl;
}
declare class Mvvm {
    static register(name: string, supportedTags: string[], elementDecoratorClass: any): void;
    static registerFilter(name: string, fn: Function): void;
    static getFilters(): {
        [name: string]: Function;
    };
    static getFiltersCode(): string;
    private static factories;
    private static filters;
    private static filtersCode;
    private logger;
    private el;
    private decorators;
    private mediators;
    private model;
    private parentView;
    private moduleInstance;
    constructor(model: any, moduleInstance: Module);
    init(el: HTMLElement, parentView: Component): void;
    dispose(): void;
    mediate(expression: string): ModelMediator;
    evaluateModel(): void;
    $apply(fn: Function, args: any[]): any;
    private populateDecorators;
    private processChildren;
    private addDecorator;
}
export { Component, Decorator, Region, Mvvm, Modules, ModuleImpl, };
